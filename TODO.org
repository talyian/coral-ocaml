* DONE Type inference on functions
  We need to apply all the constraints to the AST tree.
  Easiest way is probably to make all the nodes mutable
** TODO Reimplement type_resolver
** TODO Remove Type_graph_v1
* TODO Imports
* TODO Prelude-based operators and c compat
* TODO Implement Anonymous Tuples / lists
  #+BEGIN_SRC
  let p = (1, 2.0, "foobar")
  #+END_SRC

* [0/4] Implement Named Tuples
  #+BEGIN_SRC
  type Pt = {x: Float64, y:Float64}
  let p = Pt(10.0, 20.0)
  let q = Pt(x=10.0, y=20.0)
  let x = p.x
  let y = q.y
  #+END_SRC
** TODO implement syntax for named tuple declaration
** TODO implement syntax for named tuple constructor
** TODO implement syntax for named tuple constructor (keywords)
** TODO implement syntax for named tuple field access

* [0/3] Implement Named Unions
  #+BEGIN_SRC
  type Day = {WeekDay: Int8 + Saturday + Sunday}
  let p = Day.Saturday
  let q = Day.Sunday
  let v = match p:
    Weekday(n): n
    Saturday: 6
    Sunday: 7
  #+END_SRC
** TODO syntax for union declaration
** TODO syntax for union case-constructors
** TODO syntax for match expressions
* TODO Implement Anonymous Unions
  #+BEGIN_SRC
  let p : {Int32 | String} = if rand_bool() { 1 } else { "zero" }
  p + 3 # TypeError: (p:|String) + Int
  match p:
    Int32 (n):
    String (s):
  #+END_SRC
* [0/2] Implement Overloaded functions on types
  #+BEGIN_SRC
  let p = Pt(3.0, 4.0)
  let s = "asdf"
  length s
  length p
  #+END_SRC
** TODO Step 1: Implement with return-type inference
** TODO Step 2: Implement with Union-based parameter type inference
