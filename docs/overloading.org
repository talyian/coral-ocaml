* Overloading / Ad-hoc Polymorphism

It's nice to be able to be able to provide type-specific implementations of
functions and operators and have compile-time type-driven impl resolution:

  # overloaded addition
  let c = 1 + 2
  let d = "1" + "2"
  # overloaded functions
  print 1
  print "2"

** How to declare overloaded functions?

*** Option 1: functions always overload.

  This seems a bit error prone, but we could have a function definition always overload.

#+BEGIN_SRC coral
   func foo(a): b
   func foo(c): d # what if c is the same type as a? what if C is a subtype/supertype of a?

   module B:
     func foo(e): f # does foo(e) override <parent module>.foo?
   module C:
     func foo(g): h # pretty sure B.foo isn't a valid overload
     import B { foo } # is B.foo actually an overload set for foo(a)/foo(c)/B.foo?
     func foo(i): j # is B.foo now a valid overload? do imports add to overloads?
#+END_SRC

   Advantages: ??
   Disadvantages:
     - cannot override existing impls, so ~e~ can never be a subtype of ~a~
     - not as explicit

*** Option 2: explicit overload on local definitions,

Syntax is unfinalized yet, but what if we can declare explicitly when something is an overload?

#+BEGIN_SRC coral
  # The initial declaration doesn't necessarily need an attribute
  # should it?
  func foo(param):
    bar

  # Warning: func foo (line 4) shadows func foo (line 1)
  # should the compiler or IDE indicate that there are overloads of this function?
  func foo (param):
    bar

  # LINT: should the compiler warn if the "overload"'s domain is a superset of the
  # overloaded function? then it basically works the same as if it shadowed the
  # original
  @overload(foo)
  func foo_for_int(x:Int64):
    bar
#+END_SRC

#+BEGIN_SRC coral
  module A:
    func foo(a): _
    func foo(b): _   # (Warning/Error?): func overrides definition

  module A:
    @overload func foo(a): _
    @overload func foo(b): _

  module B:
     import A (_, foo)
     func foo(c): _ # func overrides definition
     A.foo x
     foo y
  module C:
     import A (_,, foo)
     @overload func foo(d): _ # func overloads A
     A.foo x # (without current overload)
     foo y   # (with ccurrent overload)

#+END_SRC

** Can values be overloaded?

This seems pretty odd, but you get it in languages like Haskell with type
classes or C++ with an adhoc union type that implicitly converts to its case
types. (see https://softwareengineering.stackexchange.com/questions/257065/).

If we do want overloaded values, it seems consistent to use the same decorator
for overloading functions.

#+BEGIN_SRC coral
  module D:
     let foo = 3
     @overload(foo) let foo = "three"
     # Overload(3, "three") + 4 = 7?
     # Overload(3, "three") + "four" = "threefour"?
#+END_SRC

* Open Questions

 - Should the initial declaration opt in to overloading?
   - Pros: reading the API will alert the user that this name may refer to an
     overload rather than the current definition.
   - Cons: Often the initial function doesn't know it wants to be overloaded

 - How does overload resolution work when the call-site doesn't know the type?
   #+BEGIN_SRC coral
   # stdlib
   func print(a): ...
   func println(a): { print(a); print "\n" }
   # Some library
   type Foo = ...
   func print(foo:Foo): ...
   println(foo)
   #+END_SRC

   Does the call-site need to know the type? Here we don't need run-time
   dispatch, we can just infer println to be generic over all ~a ::
   IsValidCall(print a)~. This does mean that sometimes we need to generate
   run-time checks:

   #+BEGIN_SRC coral
   let heterogeneous_list = [1, "two", 3.0]
   iter println heterogeneous_list
   #+END_SRC

   But we also know at the call-site whether something will have a run-time
   dispatch.
