# For bootstrapping purposes, we load some functionality from the c stdlib
# Eventually we should aim to be C-free

# TODO: currently this is purely a type alias
#   We need some way to make a newtype (type Cstr = Ptr[Uint8]?)
#   and to map a module's functions over a newtype.
#   Q: What does "map a module's functions over a newtype" mean?
#   A: e.g. type Id = String; id.substring(1, 3) :: Id
#   Q: What if the original module doesn't want to be completely subsumed?
#      e.g. type Id = String; id.toString() :: Id seems weird.
let Cstr = Ptr[Uint8]

extern("c", "malloc", Func[Uint64][Cstr])
extern("c", "free"  , Func[Cstr][])

extern("c", "memset", Func[addr:Cstr, char:Int32, n:Int64][Cstr])
extern("c", "memcpy", Func[dest:Cstr, src:Cstr, n:Int64][Cstr])
extern("c", "memmove", Func[dest:Cstr, src:Int32, n:Int64][Cstr])
# TODO memcmp memmem memccpy

extern("c", "printf", Func[Cstr, ...][])
