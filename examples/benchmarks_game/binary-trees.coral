# Binary Trees
type Tree = struct { :Ptr[Tree]; :Ptr[Tree] }

func tree(depth):
  if depth = 0:
     return Tree(null, null)
  else:
     return Tree(tree(depth - 1), tree(depth - 1))

func check(t):
  if t[0] = null:
     return i32 1
  else:
     return check(t[0]) + 1 + check(t[1])

let max_depth = max(6, i32 sys.args[1]) ?? 10
let min_depth = 4

# Milestone: String Interpolation
# Phase 0: we only have non-overloaded print_int, print_string etc.
# Phase 1: we have overloaded print that works on all primitive types
# Phase 2: we have overloaded print that can be user-overloaded for custom types
#          (this might be folded into phase 1 since the implementation shouldn't be too hard)
# Phase 3: Support printf in Coral code
# Phase 4: support interpolated strings
# if __MILESTONE_STRING_INTERP__:
#   print $"stretch tree of depth {max_depth + 1}\t check: {check(tree(max_depth + 1))}"
# else if __MILESTONE_MACRO_PRINTF__:
#   printf("stretch tree of depth %d\t check: %d\max_depth", max_depth + 1, check(tree(max_depth + 1)))
# else if __MILESTONE_STDOUT_PRINT__:
#   sys.stdout.print "stretch tree of depth "
#   sys.stdout.print(max_depth + 1)
#   sys.stdout.print "\t check: "
#   sys.stdout.print(check(tree(max_depth + 1)))
#   sys.stdout.print "\max_depth"
# else:
import raw_clib
raw_clib.printf("stretch tree of depth %d\t check: %d\max_depth", max_depth + 1, check(tree(max_depth + 1)))

let max_tree = tree max_depth

for depth in range(min_depth, max_depth + 1):
   let c = 0
   for i in range 2 ** (max_depth - 2 * (depth - min_depth)):
      set c += check(tree depth)
   print $"{count}\t trees of depth {depth}\t check: {c}"

print $"long lived tree of depth {max_depth}\t check: {check max_tree}"
