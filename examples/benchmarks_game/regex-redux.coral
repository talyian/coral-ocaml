# TODO: The constructors for Seq and Or can disallow Left-leaning recursion
# TODO: And and Not constructors as well
# TODO: Capturing groups
# TODO: Noncapturing groups
# TODO: Zero-width assertions
# TODO: Lookaround
# TODO: Boyer-moore skip?
# TODO: SIMD matching
type Pattern = union {
  Lit: Int8
  Seq: Pattern * Pattern
  Or: Pattern * Pattern
  Star: Pattern
  Plus: Pattern
  Opt: Pattern
  Dot
  Empty
  Error
  Escape: String
  Brackets: BracketPattern list
}

type BracketPattern = union {
  Escape: String
  Range: Int8 * Int8
  Literal: Int8
}

# This is a simpler type we can use to make creating the automaton easier
# Theoretically it is unecessary to convert Pattern to MinPattern - maybe benchmark
# to check compilation overhead?
type MinPattern = union {
  Lit: Int8
  Seq: MinPattern * MinPattern
  Or:  MinPattern * MinPattern
  Empty
  Error
  Star: MinPattern
}

# TODO: methods
func deriv(pattern:MinPattern, c:char):
  match pattern:
    Lit (x): if x = c then Empty else Error
    Seq (a, b):
      match can_be_empty a:
        true: Or(deriv(b, c), seq(deriv(a, c), b))
        false: seq(deriv(a, c), b)
    Or (a, b): Or(deriv(a, c), deriv(b, c))
    Empty: Error
    Error: Error
    Star x: Seq(deriv(x, c), Star(x))

# TODO: needed feature: generators
# TODO: needed feature: methods
# TODO: needed features: nested functions
# TODO: needed features: Pattern matching
# TODO: needed features: break
func (pattern:MinPattern).match(s, i = 0):
  if pattern = Empty: yield (i, i)
  if s.length = i: return
  let q = p
  let current_match =
    for j in range(i, s.length):
      match q.derive(s[j]):
        Error: break Fail
        Empty: break Success j
        (d): set q = d
  match current_match:
    Success j: yield (i, j)
    _ : ()
  pattern.match(s, i + 1)

func CreateTable(pattern):
  let queue = [0]
  let states = [{}]
  while true:
    state = queue.pop()
    for c in range(256):
      let s1 = state.transition(c)
      let s1 = memo_find(states, s1)
      match s1:
        Found s1: ()
        NotFound s1: queue.add s1
  return states

func optimize_table(table):

  ...

func search_pattern(string, pattern): ...
func search_table(string, table): ...

# regex-redux mainly an exercise of the regular expression library
# Short Term Goals:
# - Get this syntax parsed/typechecked, implement regex and stdout/stdin libraries
# Medium Goals:
# - Homebrew regex library, compile time precalculation
# Future Goals:
# Coral can demo a couple fancy features here:
# 1. constexpr the regexes at compile time
# 2. detect parallelism: calculate that the first for loop branches and
# the sub_patterns loop are independent automatically. This is nontrivial
# and requires using IO state in the type system.
import regex (regex)
import io (stdin, printf)

# ----
# type Fdreader = { fd: Int32 }

# stdin         -> :FdReader
# FdReader.read -> :Method[:FdReader][:String]
# seq           -> call(FdReader.read, stdin)
#               -> :String
# String.length -> :Method[:String][:Int64]
# len1          -> methodcall(String.length, seq)
#               -> :Int64
# regex         -> :Func[:String][:Regex]
# Regex.replace -> :Method[:Regex, target:String, replacement:String][:String]
# seq           -> methodcall(Regex.replace, (temp), :String)
#               -> :String
# len2          -> methodcall(String.length, seq)
#               -> :Int64

# search_patterns  -> List[String]
# p                -> String
# print            -> :Func[...][]
# regex p          -> :Regex
# (temp)           -> :Regex
# Regex.matches    -> :Method[:Regex, target:String][:MatchList]
# (temp)           -> methodcall(:Regex, Regex.matches, seq)
#                  -> :MatchList
# MatchList.length -> :Method[:MatchList][:Int32]
# (temp)           -> methodcall(MatchList.length)
#                  -> :Int32
# (temp)       ->  -> call(print, p, (temp))

# sub_patterns     ->

let fd = stdin.fd
let seq = stdin.read()
let len1 = seq.length()
let seq = regex(">.*\n|\n").replace(seq, "")
let len2 = seq.length()

let search_patterns = [
    "agggtaaa|tttaccct",
    "[cgt]gggtaaa|tttaccc[acg]",
    "a[act]ggtaaa|tttacc[agt]t",
    "ag[act]gtaaa|tttac[agt]ct",
    "agg[act]taaa|ttta[agt]cct",
    "aggg[acg]aaa|ttt[cgt]ccct",
    "agggt[cgt]aa|tt[acg]accct",
    "agggta[cgt]a|t[acg]taccct",
    "agggtaa[cgt]|[acg]ttaccct"]
for (p) in search_patterns:
   print(p, (regex p).matches(seq).length())

let sub_patterns = [
    ["tHa[Nt]",            "<4>"],
    ["aND|caN|Ha[DS]|WaS", "<3>"],
    ["a[NSt]|BY",          "<2>"],
    ["<[^>]*>",            "|"],
    ["\\|[^|][^|]*\\|",      "-"]]
for (p, repl) in sub_patterns:
   set seq = seq.replace(regex p, repl)

printf("\n{len1}\n{len2}\n{seq.length()}")